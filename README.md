# myshell
собственный интерпретатор командной строки (shell)

ОТЧЕТ

цель:
Создать командную оболочку на языке C с поддержкой современных возможностей Unix/Linux shell

что реализовано:
Архитектура системы:
Разработана модульная архитектура из 10 взаимосвязанных компонентов:
1. Лексер lexer.c/h - разбор строки на токены
2. Парсер parser.c/h - построение AST-дерева команд
3. AST ast.c/h - абстрактное синтаксическое дерево
4. Исполнитель executor.c/h- выполнение команд
5. Встроенные команды builtins.c/h - внутренние команды shell
6. Управление задачами job_control.c/h- контроль фоновых процессов
7. Основной модуль shell.c/h - главный цикл shell
8. Токены tokens.h- типы лексем
9. Тесты basic_test.c, main.c - проверка компонентов

Синтаксис команд
- Конвейеры: cmd1 | cmd2 | cmd3 
- Перенаправления: 
  - >, >> (вывод)
  - < (ввод)
  - &>, &>> (вывод+ошибки)
  - |& (конвейер с ошибками)
- Логические операторы: 
  - && (И)
  - || (ИЛИ)
- Управление потоком: ; (разделитель команд)
- Фоновый режим: &
- Подсекции: (cmd1 | cmd2)
- Кавычки: одинарные и двойные с экранированием
- Комментарии:#

Встроенные команды
- cd, pwd - навигация по файловой системе
- echo- вывод текста с поддержкой флага -n
- jobs - список фоновых задач
- fg, bg - управление задачами
- kill - завершение задач
- help - справка
- exit - выход из shell

Управление процессами
- Группы процессов: каждая задача в отдельной группе
- Фоновые задачи: запуск и отслеживание
- Состояния задач: Running, Stopped, Done
- Автоматическая очистка: завершенные задачи удаляются
- Обработка сигналов: Ctrl+C, Ctrl+Z, SIGCHLD

Интерфейс пользователя
user@host:directory$
Cокращение: /home/user -> ~
Динамический ввод: поддержка длинных команд
EOF:выход по Ctrl+D

Как работает система

Поток выполнения:
1. Ввод: пользователь вводит команду в приглашении shell
2. Лексический анализ: строка разбивается на токены
3. Синтаксический анализ: строится AST-дерево команд
4. Семантический анализ: проверяется корректность структуры
5. Выполнение: 
   - Для встроенных команд - выполнение напрямую
   - Для внешних - создание дочернего процесса через fork() + execvp()
6. Управление: shell отслеживает состояние всех процессов
есть:
- Разделение ввода/вывода: каждый процесс имеет свои файловые дескрипторы
- Изоляция процессов: фоновая задача не блокирует shell
- Обработка ошибок: корректные сообщения об ошибках
- Экранирование: поддержка спецсимволов через \
- Динамическая память: эффективное управление ресурсами

Технические детали
- Системные вызовы:fork(), execvp(), waitpid(), pipe(, dup2()
- Структуры данных: связанные списки, деревья, динамические массивы
- Обработка сигналов: sigaction(), kill(), tcsetpgrp()
- Безопасность: проверка ошибок во всех системных вызовах

Результат
Создана полноценная командная оболочка с поддержкой всех основных функций современных shell, включая управление задачами, перенаправления, конвейеры и встроенные команды. принципы работы операционных систем, управления процессами и синтаксического анализа.
